/*Feature 1: Fix avatar selection mandatory check - DONE
Feature 2: Platform width to be dynamic - DONE
Feature 3: Add coin collection
Feature 4: Add support for pausing game until enter is pressed after level is passed - DONE
Feature 5: Correct score counting towards platforms climbed so level can be passed - DONE
Feature 6: Add a game over screen - DONE

Bug 1: Blinking interval of game over restart text*/

/*Resources
Image hosting: Imgbb
*/


<!DOCTYPE html>
<html>
<head>
    <title>Climb Up! 2D</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Honk&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Honk&family=Press+Start+2P&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <style>
        #gameTitle {
            font-family: 'Press Start 2P', cursive;
            font-size: 120px;
            background: linear-gradient(0deg, #FF1D1D,  #0EAB25);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: top;
            margin: 0 0 0 0;
            -webkit-text-stroke-width: 2px;
            -webkit-text-stroke-color: white;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: black; /* Sky blue background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Press Start 2P', cursive; /* Use the selected font */
        }
        .game-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100vh;
        }
        canvas { 
            border: 2px solid #333;
            max-width: 70vw; /* Reduced from 100vw to center the game */
            max-height: 100vh;
            object-fit: contain;
            position: relative;
            z-index: 1;
        }
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Press Start 2P', cursive;
            z-index: 1000;
            padding: -20px; /* Reduced top padding */
        }
        #gameTitle {
            position: relative; /* Set relative positioning for the title */
            z-index: 1; /* Ensure the title is above the SVG */
        }
        .avatar-selection {
            display: flex;
            gap: 40px;
            margin: 36px 0 0 12px;
        }
        .avatar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 144px; /* Adjust width as needed */
            height: 144px; /* Adjust height as needed */
            border-radius: 16px;
            border: 2px solid transparent;
            background: rgba(255, 255, 255, 0.1);
            transition: background 0.3s;
            padding: 10px;
        }
        .avatar-container.selected {
            border-color: #4CAF50; /* Green border for selected avatar */
            background: rgba(76, 175, 80, 0.3); /* Light green background for selected */
        }
        .avatar-preview {
            width: 132px !important;
            height: 132px !important;
        }
        #playerName {
            padding: 12px;
            font-size: 36px; /* Updated font size */
            margin: 20px 0;
            border-radius: 12px;
            border: none;
            width: 600px; /* Increased width to fit a name of 50 characters */
            background-color: black;
            color: white;
            font-family: 'Press Start 2P', cursive;
        }
        .start-text {
            font-size: 24px;
            color: #26FA47;
            margin-top: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #score {
            position: fixed;
            top: 60px;
            left: 20px; /* Adjusted to be on the left side */
            color: white;
            font-size: 24px;
            font-family: 'Press Start 2P', cursive;
            z-index: 2;
        }
        #playerInfo {
            position: fixed;
            top: 60px;
            right: 20px; /* Added to be on the right side */
            color: white;
            font-size: 24px;
            font-family: 'Press Start 2P', cursive;
            text-align: right;
            z-index: 2;
        }
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Press Start 2P', cursive;
            z-index: 1000;
        }
        
        #gameOverTitle {
            font-family: 'Press Start 2P', cursive;
            font-size: 120px;
            background: linear-gradient(0deg, #FF1D1D, #0EAB25);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: top;
            margin: 0 0 40px 0;
            -webkit-text-stroke-width: 2px;
            -webkit-text-stroke-color: white;
        }
        
        .player-stats {
            display: flex;
            align-items: center;
            margin: 20px 0;
        }
        
        .avatar-display {
            margin-right: 20px;
        }
        
        .player-info {
            font-size: 24px;
            color: white;
        }
        
        .credit-text {
            position: absolute;
            bottom: 36px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            font-family: 'Press Start 2P', cursive;
            z-index: 1001;
        }
        
        /* Add these styles for mobile controls */
        .mobile-controls {
            display: none; /* Hidden by default, shown on mobile */
            position: fixed;
            bottom: 20px;
            width: 100%;
            z-index: 100;
        }
        
        .direction-controls {
            position: absolute;
            left: 20px;
            bottom: 0;
            display: flex;
            gap: 10px;
        }
        
        .jump-control {
            position: absolute;
            right: 20px;
            bottom: 0;
        }
        
        .control-button {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 3px solid white;
            border-radius: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            color: white;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .jump-button {
            width: 90px;
            height: 90px;
            border-radius: 45px;
            background-color: rgba(76, 175, 80, 0.5);
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }
            
            #gameCanvas {
                max-width: 100vw;
                max-height: 80vh;
            }
            
            #startScreen, #gameOverScreen {
                padding: 10px;
            }
            
            #gameTitle {
                font-size: 60px;
            }
            
            #gameOverTitle {
                font-size: 60px;
            }
            
            .avatar-selection {
                gap: 20px;
            }
            
            .avatar-container {
                width: 100px;
                height: 100px;
            }
            
            .avatar-preview {
                width: 90px !important;
                height: 90px !important;
            }
            
            #playerName {
                width: 90%;
                font-size: 24px;
            }
            
            .start-text {
                font-size: 18px;
            }
            
            #score {
                top: 10px;
                left: 10px;
                font-size: 16px;
            }
            
            #playerInfo {
                top: 10px;
                right: 10px;
                font-size: 16px;
            }
            
            .credit-text {
                font-size: 12px;
                bottom: 100px; /* Move up to make room for controls */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="startScreen">
            <a href="https://imgbb.com/"><img src="https://i.ibb.co/kj8GQhw/climbup-icon.png" alt="climbup-icon" border="0" width="355" height="355"></a>
            <h1 id="gameTitle">Climb Up!</h1>
            <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
            <div class="avatar-selection">
                <div class="avatar-container" data-avatar="blue">
                    <canvas class="avatar-preview" width="72" height="72"></canvas>
                </div>
                <div class="avatar-container" data-avatar="pink">
                    <canvas class="avatar-preview" width="72" height="72"></canvas>
                </div>
            </div>
            <p style="padding: 12px 0 0 0; font-size: 18px;">Pick your climber</p>
            <p style="padding: 36px 0 0 0;font-size: 24px;">Use arrow keys to move and spacebar to jump</p>
            <p id="startText" class="start-text">Press SPACE to start!</p>
            <p class="credit-text">Made with ❤️ by Deepanshu Arora</p>
        </div>
        
        <div id="gameOverScreen" style="display: none;">
            <h1 id="gameOverTitle">Game Over!</h1>
            <div class="player-stats">
                <div class="avatar-display">
                    <canvas id="gameOverAvatar" width="132" height="132"></canvas>
                </div>
                <div class="player-info">
                    <p id="finalPlayerName"></p>
                    <p id="finalScore"></p>
                </div>
            </div>
            <p id="restartText" class="start-text">Press SPACE to restart!</p>
            <p style="padding: 36px 0 0 0;font-size: 24px;">Press ENTER to return to main menu</p>
            <p class="credit-text">Made with ❤️ by Deepanshu Arora</p>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        <div id="score">
            <p style="font-size: 36px; color: green;">Height: <span style="font-size: 24px; color: green;">0</span>m</p>
            <p style="font-size: 24px; color: rgb(245, 41, 235);">Level: <span style="font-size: 24px; color: rgb(245, 23, 245);">1</span></p>
            <p style="font-size: 24px; color: white;">Platforms: <span style="font-size: 24px; color: white;">0</span>/20</p>
        </div>
        <div id="playerInfo">
            <p id="displayPlayerName"></p>
        </div>
        
        <div class="mobile-controls">
            <div class="direction-controls">
                <div class="control-button" id="leftButton">←</div>
                <div class="control-button" id="rightButton">→</div>
            </div>
            <div class="jump-control">
                <div class="control-button jump-button" id="jumpButton">JUMP</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = 2400;  // 800 * 3
        canvas.height = 1800; // 600 * 3

        // Game constants
        const GRAVITY = 0.5 * 3;
        const JUMP_FORCE = -12 * 3;
        const PLAYER_SIZE = 30 * 3;
        function getRandomPlatformWidth() {
            return Math.random() * (500 - 100) + 100; // Random width between 100 and 500
        }
        const PLATFORM_HEIGHT = 20 * 3;
        const FLOOR_HEIGHT = 40;  // Height of the concrete floor
        const FLOOR_EXTRA_WIDTH = 400;  // How much wider the floor is than regular platforms

        // Game state
        let gameStarted = false;
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            vx: 0,
            vy: 0,
            width: 96,
            height: 96,
            sprite: null,
            facingLeft: false,
            jumpsLeft: 2,  // Track available jumps
            onGround: false
        };
        let platforms = [];
        let score = 0;
        let selectedAvatar = null;
        let playerName = '';

        // Add camera offset tracking
        let cameraOffset = {
            y: 0
        };

        // Add level tracking
        let currentLevel = 1;
        let platformsClimbed = 0;
        const PLATFORMS_PER_LEVEL = 20;

        // Add platform ID counter
        let platformIdCounter = 0;

        // Add this variable at the top with other game variables
        let baseHeight = 0; // This will track the height of the first platform

        // Add this variable near the top with other game state variables
        let isPaused = false;

        // Add this variable near the top with other game state variables
        let highestPlatformReached = 0;

        // Add these variables near the top with other game state variables
        let coins = [];
        let coinsCollected = 0;

        // Add platform type constants
        const PLATFORM_TYPES = {
            NORMAL: 'normal',
            ICE_SPIKE: 'ice_spike',
            CLOUD: 'cloud',
            MOVING: 'moving'
        };

        // Add platform type counters to track frequency
        let platformTypeCounts = {
            [PLATFORM_TYPES.ICE_SPIKE]: 0,
            [PLATFORM_TYPES.CLOUD]: 0,
            [PLATFORM_TYPES.MOVING]: 0
        };

        // Add this class for the coin object
        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 60;
                this.rotation = 0;
                this.scale = 2;
                this.collected = false;
                this.bounceHeight = 0;
                this.bounceSpeed = 0;
                this.twinkleOpacity = 1;
                this.twinkleSize = 0;
                this.collectionAnimation = false;
            }

            update() {
                // Rotate the coin
                this.rotation += 0.1;
                
                if (this.collectionAnimation) {
                    // Bounce effect
                    this.bounceHeight += this.bounceSpeed;
                    this.bounceSpeed -= 0.5; // Gravity effect
                    
                    // Start twinkle effect when bounce is done
                    if (this.bounceSpeed < -5) {
                        this.twinkleOpacity -= 0.05;
                        this.twinkleSize += 2;
                    }
                    
                    // Remove coin when animation is complete
                    if (this.twinkleOpacity <= 0) {
                        this.collected = true;
                    }
                }
            }

            draw(ctx) {
                if (this.collected) return;
                
                ctx.save();
                
                // Apply bounce offset if being collected
                let yOffset = this.collectionAnimation ? -this.bounceHeight : 0;
                
                // Position and rotate the coin
                ctx.translate(this.x + this.width/2, this.y + this.height/18 + yOffset);
                ctx.rotate(this.rotation);
                // ctx.scale(Math.abs(Math.cos(this.rotation * 0.5)) * 0.5 + 0.5, 1); // Y-axis rotation simulation
                
                // Draw the coin
                if (this.collectionAnimation) {
                    ctx.globalAlpha = this.twinkleOpacity;
                }
                
                // Gold gradient for coin
                const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, 24);
                gradient.addColorStop(0, '#FFD700'); // Bright gold center
                gradient.addColorStop(1, '#B8860B'); // Darker gold edge
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, 24, 0, Math.PI * 2);
                ctx.fill();
                
                // Add coin details (dollar sign)
                ctx.fillStyle = '#8B4513';
                ctx.font = '4px Press Start 2P, cursive';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('₹', 0, 0);
                
                // Draw twinkle effect if being collected
                if (this.collectionAnimation && this.bounceSpeed < -5) {
                    ctx.globalAlpha = this.twinkleOpacity;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    
                    // Draw star shape
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
                        const x1 = Math.cos(angle) * this.twinkleSize;
                        const y1 = Math.sin(angle) * this.twinkleSize;
                        const x2 = Math.cos(angle + Math.PI/5) * (this.twinkleSize/2);
                        const y2 = Math.sin(angle + Math.PI/5) * (this.twinkleSize/2);
                        
                        if (i === 0) {
                            ctx.moveTo(x1, y1);
                        } else {
                            ctx.lineTo(x1, y1);
                        }
                        ctx.lineTo(x2, y2);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.restore();
            }

            collect() {
                if (!this.collectionAnimation) {
                    this.collectionAnimation = true;
                    this.bounceSpeed = 10; // Initial upward velocity
                    coinsCollected++;
                    // Play sound effect if you have one
                    // playSound('coin');
                    return true;
                }
                return false;
            }
        }

        // Add this function to place coins on random platforms
        function placeCoinOnPlatform(platform) {
            // Don't place coins on the floor
            if (platform.isFloor) return;
            
            // 30% chance to place a coin on a platform
            if (Math.random() < 0.6) {
                // Place coin in a random position on the platform
                const coinX = platform.x + Math.random() * (platform.width - 30);
                const coinY = platform.y - 60; // Position above the platform
                coins.push(new Coin(coinX, coinY));
            }
        }

        // Update game background and add brick texture
        function createBrickPattern() {
            const patternCanvas = document.createElement('canvas');
            const patternContext = patternCanvas.getContext('2d');
            patternCanvas.width = 32;
            patternCanvas.height = 16;

            // Brick color (Mario-style red bricks)
            patternContext.fillStyle = '#c84c0c';  // Base brick color
            patternContext.fillRect(0, 0, 32, 16);

            // Add brick details
            patternContext.fillStyle = '#a13a0c';  // Darker shade for details
            patternContext.fillRect(0, 13, 32, 3); // Bottom shadow
            patternContext.fillRect(16, 0, 2, 16); // Vertical line

            return ctx.createPattern(patternCanvas, 'repeat');
        }

        // Update platform management and scrolling
        function managePlatforms() {
            const playerZone = Math.floor(player.y / 300);
            const minY = player.y - (10 * 300);
            const maxY = player.y + (10 * 300);

            // Keep floor and filter other platforms
            platforms = platforms.filter(platform => 
                platform.isFloor || (platform.y > minY && platform.y < maxY)
            );

            // Sort platforms by height (lowest to highest)
            platforms.sort((a, b) => b.y - a.y);

            // If this is the first platform generation, set the base height
            if (baseHeight === 0 && platforms.length > 0) {
                baseHeight = platforms[0].y;
            }

            // Count existing platform types
            platformTypeCounts = {
                [PLATFORM_TYPES.ICE_SPIKE]: 0,
                [PLATFORM_TYPES.CLOUD]: 0,
                [PLATFORM_TYPES.MOVING]: 0
            };
            
            platforms.forEach(platform => {
                if (platform.type && platform.type !== PLATFORM_TYPES.NORMAL) {
                    platformTypeCounts[platform.type]++;
                }
            });

            // Generate new platforms if needed
            while (platforms.length < 20) {
                let newY;
                if (platforms.length === 0) {
                    newY = player.y;
                    baseHeight = newY;
                } else {
                    const highestPlatform = platforms.reduce((prev, current) => 
                        prev.y < current.y ? prev : current
                    );
                    newY = highestPlatform.y - 300;
                }

                // Determine platform type
                let platformType = PLATFORM_TYPES.NORMAL;
                
                // Only add special platforms if we're not at the beginning of the game
                if (platforms.length > 5) {
                    // Randomly select a special platform type with constraints
                    const specialTypes = [
                        { type: PLATFORM_TYPES.ICE_SPIKE, count: platformTypeCounts[PLATFORM_TYPES.ICE_SPIKE], maxCount: 1 },
                        { type: PLATFORM_TYPES.CLOUD, count: platformTypeCounts[PLATFORM_TYPES.CLOUD], maxCount: 1 },
                        { type: PLATFORM_TYPES.MOVING, count: platformTypeCounts[PLATFORM_TYPES.MOVING], maxCount: 1 }
                    ];
                    
                    // Filter types that haven't reached their max count
                    const availableTypes = specialTypes.filter(t => t.count < t.maxCount);
                    
                    // 30% chance to create a special platform if available
                    if (availableTypes.length > 0 && Math.random() < 0.3) {
                        // Randomly select one of the available special types
                        const selectedType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                        platformType = selectedType.type;
                        platformTypeCounts[platformType]++;
                    }
                }

                const platformWidth = getRandomPlatformWidth();
                
                // Create the new platform with appropriate properties
                const newPlatform = {
                    x: Math.random() * (canvas.width - platformWidth),
                    y: newY,
                    width: platformWidth,
                    height: PLATFORM_HEIGHT,
                    color: getPlatformColor(platformType),
                    type: platformType,
                    visited: false,
                    isFloor: false,
                    number: 0, // Will be updated later
                    
                    // Additional properties for special platforms
                    originalX: 0, // For moving platforms
                    movingDirection: 1, // For moving platforms (1: right, -1: left)
                    moveSpeed: 2, // For moving platforms
                    cloudOpacity: 1, // For cloud platforms
                    cloudFading: false, // For cloud platforms
                    spikeHeight: 30, // For ice spike platforms
                    spikePosition: Math.random() < 0.5 ? 'left' : 'right' // Randomly place spike on left or right
                };
                
                // Set original X position for moving platforms
                newPlatform.originalX = newPlatform.x;
                
                platforms.push(newPlatform);
                
                // Place coins on the new platform (except on ice spike platforms)
                if (platformType !== PLATFORM_TYPES.ICE_SPIKE) {
                    placeCoinOnPlatform(newPlatform);
                }
            }

            // Update platform numbers based on their height relative to base
            platforms.forEach(platform => {
                platform.number = Math.floor((baseHeight - platform.y) / 300);
            });
            
            // Update special platform behaviors
            updateSpecialPlatforms();
            
            // Filter out collected coins
            coins = coins.filter(coin => !coin.collected);
            
            // Remove coins that are too far away
            coins = coins.filter(coin => coin.y > minY && coin.y < maxY);
        }

        // Function to get platform color based on type
        function getPlatformColor(platformType) {
            switch (platformType) {
                case PLATFORM_TYPES.ICE_SPIKE:
                    return '#87CEFA'; // Light sky blue for ice
                case PLATFORM_TYPES.CLOUD:
                    return '#FFFFFF'; // White for cloud
                case PLATFORM_TYPES.MOVING:
                    return '#FF9800'; // Orange for moving platform
                default:
                    return '#c84c0c'; // Default brick color
            }
        }

        // Function to update special platform behaviors
        function updateSpecialPlatforms() {
            platforms.forEach(platform => {
                // Update moving platforms
                if (platform.type === PLATFORM_TYPES.MOVING) {
                    platform.x += platform.moveSpeed * platform.movingDirection;
                    
                    // Change direction when reaching limits
                    if (platform.x > platform.originalX + platform.width) {
                        platform.movingDirection = -1;
                    } else if (platform.x < platform.originalX - platform.width) {
                        platform.movingDirection = 1;
                    }
                }
                
                // Update cloud platforms
                if (platform.type === PLATFORM_TYPES.CLOUD && platform.cloudFading) {
                    platform.cloudOpacity -= 0.02;
                    
                    // Remove platform when fully transparent
                    if (platform.cloudOpacity <= 0) {
                        platform.cloudOpacity = 0;
                        // Mark for removal in next filter cycle
                        platform.y = player.y + 1000; 
                    }
                }
            });
        }

        // Draw functions
        function drawPlayer() {
            if (!player.sprite) {
                player.sprite = createTurtleSprite();
            }

            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Optional: Add jump effect
            if (!player.onGround) {
                // Add slight rotation or scale effect during jumps
                const jumpScale = 1 + (Math.abs(player.vy) * 0.02);
                ctx.scale(1, jumpScale);
            }
            
            if (player.facingLeft) {
                ctx.scale(-1, 1);
                ctx.drawImage(player.sprite, -player.width, 0, player.width, player.height);
            } else {
                ctx.drawImage(player.sprite, 0, 0, player.width, player.height);
            }
            
            // Optional: Draw jump indicators
            // if (player.jumpsLeft > 0 && !player.onGround) {
            //     ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            //     ctx.beginPath();
            //     ctx.arc(0, player.height/2, 10, 0, Math.PI * 2);
            //     ctx.fill();
            // }
            
            ctx.restore();
        }

        function drawPlatforms(ctx) {
            platforms.forEach(platform => {
                if (platform.y + cameraOffset.y > -PLATFORM_HEIGHT && 
                    platform.y + cameraOffset.y < canvas.height) {
                    
                    if (platform.isFloor) {
                        // Draw concrete floor with gradient and texture
                        const gradient = ctx.createLinearGradient(
                            platform.x, platform.y,
                            platform.x, platform.y + platform.height
                        );
                        gradient.addColorStop(0, '#a0a0a0');
                        gradient.addColorStop(1, '#686868');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                        
                        // Add concrete texture
                        ctx.fillStyle = '#7a7a7a';
                        for (let i = 0; i < platform.width; i += 20) {
                            for (let j = 0; j < platform.height; j += 20) {
                                if ((i + j) % 40 === 0) {
                                    ctx.fillRect(
                                        platform.x + i, platform.y + j,
                                        10, 10
                                    );
                                }
                            }
                        }
                        
                        // Add platform border
                        ctx.strokeStyle = '#505050';
                        ctx.lineWidth = 4;
                        ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                        
                        // Add subtle shadow at the top
                        const shadowGradient = ctx.createLinearGradient(
                            platform.x, platform.y,
                            platform.x, platform.y + 10
                        );
                        shadowGradient.addColorStop(0, 'rgba(0,0,0,0.3)');
                        shadowGradient.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = shadowGradient;
                        ctx.fillRect(platform.x, platform.y, platform.width, 10);
                    } else {
                        // Draw special platforms based on type
                        switch (platform.type) {
                            case PLATFORM_TYPES.ICE_SPIKE:
                                // Draw ice platform
                                ctx.fillStyle = platform.color;
                                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                                
                                // Add ice texture
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                                for (let i = 0; i < platform.width; i += 15) {
                                    ctx.fillRect(platform.x + i, platform.y, 5, platform.height);
                                }
                                
                                // Draw spike
                                ctx.fillStyle = '#FFFFFF'; // White spike
                                ctx.beginPath();
                                
                                if (platform.spikePosition === 'left') {
                                    // Draw spike on left edge
                                    ctx.moveTo(platform.x, platform.y);
                                    ctx.lineTo(platform.x, platform.y - platform.spikeHeight);
                                    ctx.lineTo(platform.x + 20, platform.y);
                                } else {
                                    // Draw spike on right edge
                                    ctx.moveTo(platform.x + platform.width, platform.y);
                                    ctx.lineTo(platform.x + platform.width, platform.y - platform.spikeHeight);
                                    ctx.lineTo(platform.x + platform.width - 20, platform.y);
                                }
                                
                                ctx.closePath();
                                ctx.fill();
                                
                                // Add platform border
                                ctx.strokeStyle = '#4682B4'; // Steel blue border
                                ctx.lineWidth = 2;
                                ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                                break;
                                
                            case PLATFORM_TYPES.CLOUD:
                                // Set opacity for fading effect
                                ctx.globalAlpha = platform.cloudOpacity;
                                
                                // Draw cloud platform
                                // Base rectangle
                                ctx.fillStyle = platform.color;
                                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                                
                                // Cloud bumps on top
                                const bumpCount = Math.floor(platform.width / 40);
                                const bumpWidth = platform.width / bumpCount;
                                
                                for (let i = 0; i < bumpCount; i++) {
                                    ctx.beginPath();
                                    ctx.arc(
                                        platform.x + (i * bumpWidth) + (bumpWidth / 2),
                                        platform.y,
                                        bumpWidth / 2,
                                        0, Math.PI, true
                                    );
                                    ctx.fill();
                                }
                                
                                // Reset opacity
                                ctx.globalAlpha = 1;
                                break;
                                
                            case PLATFORM_TYPES.MOVING:
                                // Draw moving platform
                                ctx.fillStyle = platform.color;
                                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                                
                                // Add direction indicator arrows
                                ctx.fillStyle = '#FFFFFF';
                                
                                // Left arrow
                                ctx.beginPath();
                                ctx.moveTo(platform.x + 20, platform.y + platform.height / 2);
                                ctx.lineTo(platform.x + 40, platform.y + platform.height / 4);
                                ctx.lineTo(platform.x + 40, platform.y + platform.height * 3/4);
                                ctx.closePath();
                                ctx.fill();
                                
                                // Right arrow
                                ctx.beginPath();
                                ctx.moveTo(platform.x + platform.width - 20, platform.y + platform.height / 2);
                                ctx.lineTo(platform.x + platform.width - 40, platform.y + platform.height / 4);
                                ctx.lineTo(platform.x + platform.width - 40, platform.y + platform.height * 3/4);
                                ctx.closePath();
                                ctx.fill();
                                
                                // Add platform border
                                ctx.strokeStyle = '#CC7000';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                                break;
                                
                            default:
                                // Regular platform drawing (brick pattern)
                                const brickPattern = createBrickPattern();
                                ctx.fillStyle = brickPattern;
                                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                                
                                ctx.strokeStyle = '#8b0000';
                                ctx.lineWidth = 4;
                                ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                                break;
                        }
                        
                        // Draw platform number (only for non-floor platforms)
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 30px Arial';
                        ctx.textAlign = 'center';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 3;
                        
                        const displayNumber = Math.max(0, platform.number);
                        ctx.strokeText(displayNumber,
                            platform.x + platform.width / 2,
                            platform.y + platform.height / 2 + 10);
                        ctx.fillText(displayNumber,
                            platform.x + platform.width / 2,
                            platform.y + platform.height / 2 + 10);
                    }
                }
            });
        }

        // Update draw function
        function draw() {
            // Clear canvas with black background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update camera to follow player
            const targetCameraY = -(player.y - canvas.height * 0.6);
            cameraOffset.y += (targetCameraY - cameraOffset.y) * 0.1;

            ctx.save();
            ctx.translate(0, cameraOffset.y);
            
            // Draw platforms using the new function
            drawPlatforms(ctx);
            
            // Draw coins
            coins.forEach(coin => {
                coin.draw(ctx);
            });

            drawPlayer();
            
            ctx.restore();

            drawUI();
        }

        // Update platform generation in the update function
        function update() {
            if (!gameStarted || isPaused) return;

            // Movement controls
            if (keys['ArrowLeft'] || keys['Left']) {
                player.x -= 15;
                player.facingLeft = true;
            }
            if (keys['ArrowRight'] || keys['Right']) {
                player.x += 15;
                player.facingLeft = false;
            }

            // Apply gravity
            player.vy += GRAVITY;
            player.y += player.vy;

            // Manage platforms
            managePlatforms();

            // Platform collision
            let isOnPlatform = false;
            let currentPlatformNumber = 0;
            
            platforms.forEach(platform => {
                if (checkPlatformCollision(platform)) {
                    if (player.vy > 0) {
                        player.y = platform.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                        player.jumpsLeft = 2;
                        isOnPlatform = true;
                        
                        // Update current platform number when landing on a platform
                        currentPlatformNumber = Math.max(currentPlatformNumber, platform.number);
                        
                        // Mark platform as visited (for visual feedback if needed)
                        platform.visited = true;
                    }
                }
            });
            
            // Update highest platform reached and platforms climbed
            if (currentPlatformNumber > highestPlatformReached) {
                // Calculate how many new platforms were crossed
                const newPlatformsCrossed = currentPlatformNumber - highestPlatformReached;
                
                // Update platforms climbed count
                platformsClimbed += newPlatformsCrossed;
                
                // Update highest platform reached
                highestPlatformReached = currentPlatformNumber;
            }

            // Update ground state
            if (!isOnPlatform && player.onGround) {
                player.onGround = false;
            }

            // Coin collision detection and collection
            coins.forEach(coin => {
                if (!coin.collectionAnimation && checkCoinCollision(coin)) {
                    coin.collect();
                }
                coin.update();
            });

            // Game over check - adjust for new platform management
            const lowestPlatform = platforms.reduce((prev, current) => 
                prev.y > current.y ? prev : current
            );
            
            if (player.y > lowestPlatform.y + 500) {
                gameStarted = false;
                showGameOverScreen();
            }

            // Screen boundaries (wrap-around logic)
            if (player.x + player.width < 0) {
                player.x = canvas.width;
            } else if (player.x > canvas.width) {
                player.x = -player.width;
            }

            // Update score
            score = Math.max(score, Math.floor((canvas.height - player.y) / 30)); // Adjusted for new scale
            updateScoreDisplay();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Input handling
        const keys = {};
        document.addEventListener('keydown', function(e) {
            keys[e.code] = true;
            
            // Check if game over screen is visible
            const gameOverScreen = document.getElementById('gameOverScreen');
            if (gameOverScreen.style.display === 'flex') {
                if (e.code === 'Space') {
                    // Restart the game with the same player
                    gameOverScreen.style.display = 'none';
                    document.getElementById('score').style.display = 'block';
                    document.getElementById('playerInfo').style.display = 'block';
                    gameStarted = true;
                    resetGame();
                    return;
                } else if (e.code === 'Enter') {
                    // Return to the start screen
                    gameOverScreen.style.display = 'none';
                    document.getElementById('startScreen').style.display = 'flex';
                    document.getElementById('score').style.display = 'block';
                    document.getElementById('playerInfo').style.display = 'block';
                    selectedAvatar = null; // Reset avatar selection
                    return;
                }
            }
            
            // Handle game start
            if (e.code === 'Space' && !gameStarted) {
                startGame();
                return;
            }
            
            // If game is paused, only respond to Enter key
            if (isPaused) {
                if (e.code === 'Enter' && checkLevelCompletion()) {
                    isPaused = false;
                    startNextLevel();
                }
                return; // Ignore all other keys when paused
            }
            
            // Handle jumping (only when not paused)
            if (e.code === 'Space' && gameStarted) {
                if (player.onGround) {
                    // First jump
                    player.vy = JUMP_FORCE;
                    player.onGround = false;
                    player.jumpsLeft = 1; // One jump remaining
                } else if (player.jumpsLeft > 0) {
                    // Double jump
                    player.vy = JUMP_FORCE * 0.8; // Slightly weaker second jump
                    player.jumpsLeft = 0;
                }
            }
        });

        document.addEventListener('keyup', function(e) {
            keys[e.code] = false;
        });

        // Game controls
        function updateControls() {
            if (keys['ArrowLeft'] || keys['Left']) player.vx = -5;
            else if (keys['ArrowRight'] || keys['Right']) player.vx = 5;
            else player.vx = 0;
        }

        // Initialize game
        function startGame() {
            playerName = document.getElementById('playerName').value.trim();
            console.log('Player Name:', playerName);
            console.log('Selected Avatar:', selectedAvatar);
            
            if (!playerName && !selectedAvatar) {
                alert('Please enter your name and select an avatar!');
                return;
            }
            else if (!playerName) {
                alert('Please enter your name!');
                return;
            }
            else if (!selectedAvatar) {
                alert('Please select an avatar!');
                return;
            }
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('displayPlayerName').textContent = playerName;
            gameStarted = true;
            resetGame();
        }

        function resetGame() {
            baseHeight = 0;
            platforms = [];
            coins = []; // Reset coins array
            coinsCollected = 0; // Reset coins collected counter
            
            // Create the concrete floor platform first
            const floorPlatform = {
                x: (canvas.width - (getRandomPlatformWidth() + FLOOR_EXTRA_WIDTH)) / 2, // Centered, wider platform
                y: canvas.height - FLOOR_HEIGHT,
                width: getRandomPlatformWidth() + FLOOR_EXTRA_WIDTH,
                height: FLOOR_HEIGHT,
                isFloor: true, // Special flag for the floor
                color: '#808080', // Concrete gray color
                number: 0,
                visited: false
            };
            platforms.push(floorPlatform);
            
            // Create regular platforms starting higher up
            for (let i = 1; i < 20; i++) {
                const platformY = canvas.height - FLOOR_HEIGHT - (i * 300);
                const newPlatform = {
                    x: Math.random() * (canvas.width - getRandomPlatformWidth()),
                    y: platformY,
                    width: getRandomPlatformWidth(),
                    height: PLATFORM_HEIGHT,
                    color: '#c84c0c',
                    number: i,
                    visited: false,
                    isFloor: false
                };
                
                platforms.push(newPlatform);
                
                // Place coins on the new platform
                placeCoinOnPlatform(newPlatform);
            }

            // Set base height to the floor platform
            baseHeight = floorPlatform.y;

            // Position player on the floor platform
            player.x = canvas.width / 2;
            player.y = floorPlatform.y - player.height;
            player.vx = 0;
            player.vy = 0;
            player.jumpsLeft = 2;
            player.onGround = true;
            
            score = 0;
            platformsClimbed = 0;
            highestPlatformReached = 0; // Reset the highest platform reached
            cameraOffset.y = 0;
        }

        // Avatar selection
        document.querySelectorAll('.avatar-container').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.avatar-container').forEach(opt => 
                    opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedAvatar = option.dataset.avatar;
                player.sprite = createTurtleSprite(selectedAvatar);
            });
        });

        // Initialize preview canvases
        document.querySelectorAll('.avatar-container').forEach(option => {
            const canvas = option.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            const sprite = createTurtleSprite(option.dataset.avatar);
            ctx.drawImage(sprite, 0, 0);
        });

        // Start game loop
        gameLoop();
        
        // Set initial platform
        managePlatforms();

        // Add this after your canvas setup
        function createTurtleSprite(avatarColor) {
            const spriteCanvas = document.createElement('canvas');
            const spriteCtx = spriteCanvas.getContext('2d');
            spriteCanvas.width = 96;  // 32 * 3
            spriteCanvas.height = 96; // 32 * 3

            // Colors based on the avatar color
            const shell = avatarColor === 'blue' ? '#3498db' : '#e91e63'; // Blue or Pink shell
            const skin = '#82e0aa';   // Lighter green for skin
            const mask = avatarColor === 'blue' ? '#3498db' : '#e91e63';  // Blue or Pink mask

            // Draw the turtle pixel by pixel (scaled up 3x)
            const pixels = [
                // Shell pattern (darker green)
                [12,6, 36,36, shell], // Shell outline
                [15,9, 30,30, '#27ae60'], // Inner shell
                
                // Body (lighter green)
                [18,39, 12,9, skin],  // Lower body
                [9,18, 9,12, skin],   // Left arm
                [30,18, 9,12, skin],  // Right arm
                
                // Mask (blue or pink)
                [12,12, 24,6, mask],   // Mask strip
                
                // Eyes (white with black pupils)
                [15,12, 6,6, 'white'],
                [27,12, 6,6, 'white'],
                [18,15, 3,3, 'black'],
                [30,15, 3,3, 'black'],
            ];

            // Draw each pixel section
            pixels.forEach(([x, y, w, h, color]) => {
                spriteCtx.fillStyle = color;
                spriteCtx.fillRect(x, y, w, h);
            });

            return spriteCanvas;
        }

        function checkPlatformCollision(platform) {
            // Basic collision detection
            const collision = player.y + player.height > platform.y &&
                             player.y < platform.y + platform.height &&
                             player.x + player.width > platform.x &&
                             player.x < platform.x + platform.width;
            
            if (collision) {
                // Handle special platform behaviors on collision
                if (platform.type === PLATFORM_TYPES.CLOUD && !platform.cloudFading) {
                    platform.cloudFading = true; // Start fading the cloud platform
                }
                
                // Check for spike collision
                if (platform.type === PLATFORM_TYPES.ICE_SPIKE) {
                    const spikeX = platform.spikePosition === 'left' ? platform.x : platform.x + platform.width - 20;
                    const spikeCollision = player.y + player.height > platform.y - platform.spikeHeight &&
                                          player.y < platform.y &&
                                          player.x + player.width > spikeX &&
                                          player.x < spikeX + 5;
                    
                    if (spikeCollision) {
                        // Player hit a spike - implement damage or game over
                        gameStarted = false;
                        showGameOverScreen();
                        return false;
                    }
                }
            }
            
            return collision;
        }

        // Add level completion check
        function checkLevelCompletion() {
            if (platformsClimbed >= PLATFORMS_PER_LEVEL) {
                isPaused = true; // Pause the game when level is completed
                return true;
            }
            return false;
        }

        // Add next level function
        function startNextLevel() {
            currentLevel++;
            platformsClimbed = 0;
            // Increase difficulty with each level
            GRAVITY *= 1.1;
            JUMP_FORCE *= 1.1;
            // Reset player position but keep height progress
            const currentHeight = player.y;
            resetGame();
            player.y = currentHeight;
        }

        // Update UI colors for better visibility on black background
        function drawUI() {
            // Draw score with shadow for better visibility
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            
            // Reset shadow
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Level completion message
            if (checkLevelCompletion()) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, canvas.height/2 - 100, canvas.width, 200);
                
                ctx.fillStyle = '#4CAF50';
                ctx.font = '72px "Press Start 2P", cursive';
                ctx.textAlign = 'center';
                ctx.fillText(`Level ${currentLevel} Complete!`, canvas.width/2, canvas.height/2);
                ctx.font = '36px "Press Start 2P", cursive';
                ctx.fillText('Press ENTER to start next level', canvas.width/2, canvas.height/2 + 60);
                ctx.textAlign = 'left';
            }
        }

        // Optional: Add Mario-style platform break effect when landing
        function createPlatformParticles(x, y) {
            // Add simple particle effect when landing
            const particles = [];
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x + Math.random() * getRandomPlatformWidth(),
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: -Math.random() * 5,
                    size: 5,
                    life: 1
                });
            }
            return particles;
        }

        // Function to make the text blink
        function startBlinkingText() {
            const startText = document.getElementById('startText');
            setInterval(() => {
                startText.style.opacity = startText.style.opacity === '0' ? '1' : '0'; // Toggle opacity
            }, 600); // 600 milliseconds
        }
        // Call the function to start blinking when the game starts
        startBlinkingText();

        // Add this function to show the game over screen
        function showGameOverScreen() {
            // Hide the game canvas and score display
            document.getElementById('score').style.display = 'none';
            document.getElementById('playerInfo').style.display = 'none';
            
            // Set the player name and score
            document.getElementById('finalPlayerName').textContent = `Player: ${playerName}`;
            document.getElementById('finalScore').textContent = `Final Height: ${score}m | Coins: ${coinsCollected}`;
            
            // Draw the player's avatar on the game over screen
            const avatarCanvas = document.getElementById('gameOverAvatar');
            const avatarCtx = avatarCanvas.getContext('2d');
            const avatarSprite = createTurtleSprite(selectedAvatar);
            avatarCtx.drawImage(avatarSprite, 0, 0, 132, 132);
            
            // Show the game over screen
            document.getElementById('gameOverScreen').style.display = 'flex';
            
            // Start the blinking text effect
            startBlinkingGameOverText();
        }

        // Add this function to make the restart text blink
        function startBlinkingGameOverText() {
            const restartText = document.getElementById('restartText');
            setInterval(() => {
                restartText.style.opacity = restartText.style.opacity === '0' ? '1' : '0'; // Toggle opacity
            }, 600); // 600 milliseconds
        }

        // Add a new function to update the score display
        function updateScoreDisplay() {
            const scoreElement = document.getElementById('score');
            scoreElement.innerHTML = `
            <p style="font-size: 36px; color: green;">Height: <span style="font-size: 36px; color: green;">${score}</span>m</p>
            <p style="font-size: 24px; color: rgb(245, 41, 235);">Level: <span style="font-size: 24px; color: rgb(245, 23, 245);">${currentLevel}</span></p>
            <p style="font-size: 24px; color: white;">Platforms: <span style="font-size: 24px; color: white;">${platformsClimbed}</span>/${PLATFORMS_PER_LEVEL}</p>
            <p style="font-size: 24px; color: gold;">Coins: <span style="font-size: 24px; color: gold;">${coinsCollected}</span></p>
            `;
        }

        // Add this function to check for coin collision
        function checkCoinCollision(coin) {
            return player.y + player.height > coin.y &&
                   player.y < coin.y + coin.height &&
                   player.x + player.width > coin.x &&
                   player.x < coin.x + coin.width;
        }
    </script>
</body>
</html>